// Code generated by protoc-gen-go.
// source: anauth/psys/psyspb/psys.proto
// DO NOT EDIT!

/*
Package psyspb is a generated protocol buffer package.

It is generated from these files:
	anauth/psys/psyspb/psys.proto

It has these top-level messages:
	CARequest
	CAResponse
	ProofRandData
	Cert
	GenerateNymRequest
	GenerateNymResponse
	ObtainCredRequest
	ObtainCredResponse
	TransferCredRequest
	TransferCredResponse
	GenerateNymProofRandData
	BytesPair
	PedersenDecommitment
	Cred
	Transcript
	ObtainCredProofRandData
	TransferCredProofRandData
*/
package psyspb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CARequest struct {
	// Types that are valid to be assigned to Type:
	//	*CARequest_ProofRandData
	//	*CARequest_ProofData
	Type isCARequest_Type `protobuf_oneof:"type"`
}

func (m *CARequest) Reset()                    { *m = CARequest{} }
func (m *CARequest) String() string            { return proto.CompactTextString(m) }
func (*CARequest) ProtoMessage()               {}
func (*CARequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isCARequest_Type interface {
	isCARequest_Type()
}

type CARequest_ProofRandData struct {
	ProofRandData *ProofRandData `protobuf:"bytes,1,opt,name=proofRandData,oneof"`
}
type CARequest_ProofData struct {
	ProofData []byte `protobuf:"bytes,2,opt,name=proofData,proto3,oneof"`
}

func (*CARequest_ProofRandData) isCARequest_Type() {}
func (*CARequest_ProofData) isCARequest_Type()     {}

func (m *CARequest) GetType() isCARequest_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *CARequest) GetProofRandData() *ProofRandData {
	if x, ok := m.GetType().(*CARequest_ProofRandData); ok {
		return x.ProofRandData
	}
	return nil
}

func (m *CARequest) GetProofData() []byte {
	if x, ok := m.GetType().(*CARequest_ProofData); ok {
		return x.ProofData
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CARequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CARequest_OneofMarshaler, _CARequest_OneofUnmarshaler, _CARequest_OneofSizer, []interface{}{
		(*CARequest_ProofRandData)(nil),
		(*CARequest_ProofData)(nil),
	}
}

func _CARequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CARequest)
	// type
	switch x := m.Type.(type) {
	case *CARequest_ProofRandData:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProofRandData); err != nil {
			return err
		}
	case *CARequest_ProofData:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.ProofData)
	case nil:
	default:
		return fmt.Errorf("CARequest.Type has unexpected type %T", x)
	}
	return nil
}

func _CARequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CARequest)
	switch tag {
	case 1: // type.proofRandData
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ProofRandData)
		err := b.DecodeMessage(msg)
		m.Type = &CARequest_ProofRandData{msg}
		return true, err
	case 2: // type.proofData
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Type = &CARequest_ProofData{x}
		return true, err
	default:
		return false, nil
	}
}

func _CARequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CARequest)
	// type
	switch x := m.Type.(type) {
	case *CARequest_ProofRandData:
		s := proto.Size(x.ProofRandData)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CARequest_ProofData:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ProofData)))
		n += len(x.ProofData)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CAResponse struct {
	// Types that are valid to be assigned to Type:
	//	*CAResponse_Challenge
	//	*CAResponse_Cert
	Type isCAResponse_Type `protobuf_oneof:"type"`
}

func (m *CAResponse) Reset()                    { *m = CAResponse{} }
func (m *CAResponse) String() string            { return proto.CompactTextString(m) }
func (*CAResponse) ProtoMessage()               {}
func (*CAResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isCAResponse_Type interface {
	isCAResponse_Type()
}

type CAResponse_Challenge struct {
	Challenge []byte `protobuf:"bytes,1,opt,name=challenge,proto3,oneof"`
}
type CAResponse_Cert struct {
	Cert *Cert `protobuf:"bytes,2,opt,name=cert,oneof"`
}

func (*CAResponse_Challenge) isCAResponse_Type() {}
func (*CAResponse_Cert) isCAResponse_Type()      {}

func (m *CAResponse) GetType() isCAResponse_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *CAResponse) GetChallenge() []byte {
	if x, ok := m.GetType().(*CAResponse_Challenge); ok {
		return x.Challenge
	}
	return nil
}

func (m *CAResponse) GetCert() *Cert {
	if x, ok := m.GetType().(*CAResponse_Cert); ok {
		return x.Cert
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CAResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CAResponse_OneofMarshaler, _CAResponse_OneofUnmarshaler, _CAResponse_OneofSizer, []interface{}{
		(*CAResponse_Challenge)(nil),
		(*CAResponse_Cert)(nil),
	}
}

func _CAResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CAResponse)
	// type
	switch x := m.Type.(type) {
	case *CAResponse_Challenge:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Challenge)
	case *CAResponse_Cert:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Cert); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CAResponse.Type has unexpected type %T", x)
	}
	return nil
}

func _CAResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CAResponse)
	switch tag {
	case 1: // type.challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Type = &CAResponse_Challenge{x}
		return true, err
	case 2: // type.cert
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Cert)
		err := b.DecodeMessage(msg)
		m.Type = &CAResponse_Cert{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CAResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CAResponse)
	// type
	switch x := m.Type.(type) {
	case *CAResponse_Challenge:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Challenge)))
		n += len(x.Challenge)
	case *CAResponse_Cert:
		s := proto.Size(x.Cert)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Random data for schnorr proof
type ProofRandData struct {
	X []byte `protobuf:"bytes,1,opt,name=X,proto3" json:"X,omitempty"`
	A []byte `protobuf:"bytes,2,opt,name=A,proto3" json:"A,omitempty"`
	B []byte `protobuf:"bytes,3,opt,name=B,proto3" json:"B,omitempty"`
}

func (m *ProofRandData) Reset()                    { *m = ProofRandData{} }
func (m *ProofRandData) String() string            { return proto.CompactTextString(m) }
func (*ProofRandData) ProtoMessage()               {}
func (*ProofRandData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ProofRandData) GetX() []byte {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *ProofRandData) GetA() []byte {
	if m != nil {
		return m.A
	}
	return nil
}

func (m *ProofRandData) GetB() []byte {
	if m != nil {
		return m.B
	}
	return nil
}

type Cert struct {
	BlindedA []byte `protobuf:"bytes,1,opt,name=BlindedA,proto3" json:"BlindedA,omitempty"`
	BlindedB []byte `protobuf:"bytes,2,opt,name=BlindedB,proto3" json:"BlindedB,omitempty"`
	R        []byte `protobuf:"bytes,3,opt,name=R,proto3" json:"R,omitempty"`
	S        []byte `protobuf:"bytes,4,opt,name=S,proto3" json:"S,omitempty"`
}

func (m *Cert) Reset()                    { *m = Cert{} }
func (m *Cert) String() string            { return proto.CompactTextString(m) }
func (*Cert) ProtoMessage()               {}
func (*Cert) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Cert) GetBlindedA() []byte {
	if m != nil {
		return m.BlindedA
	}
	return nil
}

func (m *Cert) GetBlindedB() []byte {
	if m != nil {
		return m.BlindedB
	}
	return nil
}

func (m *Cert) GetR() []byte {
	if m != nil {
		return m.R
	}
	return nil
}

func (m *Cert) GetS() []byte {
	if m != nil {
		return m.S
	}
	return nil
}

type GenerateNymRequest struct {
	// Types that are valid to be assigned to Type:
	//	*GenerateNymRequest_ProofRandData
	//	*GenerateNymRequest_ProofData
	Type isGenerateNymRequest_Type `protobuf_oneof:"type"`
}

func (m *GenerateNymRequest) Reset()                    { *m = GenerateNymRequest{} }
func (m *GenerateNymRequest) String() string            { return proto.CompactTextString(m) }
func (*GenerateNymRequest) ProtoMessage()               {}
func (*GenerateNymRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isGenerateNymRequest_Type interface {
	isGenerateNymRequest_Type()
}

type GenerateNymRequest_ProofRandData struct {
	ProofRandData *GenerateNymProofRandData `protobuf:"bytes,1,opt,name=proofRandData,oneof"`
}
type GenerateNymRequest_ProofData struct {
	ProofData []byte `protobuf:"bytes,2,opt,name=proofData,proto3,oneof"`
}

func (*GenerateNymRequest_ProofRandData) isGenerateNymRequest_Type() {}
func (*GenerateNymRequest_ProofData) isGenerateNymRequest_Type()     {}

func (m *GenerateNymRequest) GetType() isGenerateNymRequest_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *GenerateNymRequest) GetProofRandData() *GenerateNymProofRandData {
	if x, ok := m.GetType().(*GenerateNymRequest_ProofRandData); ok {
		return x.ProofRandData
	}
	return nil
}

func (m *GenerateNymRequest) GetProofData() []byte {
	if x, ok := m.GetType().(*GenerateNymRequest_ProofData); ok {
		return x.ProofData
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GenerateNymRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GenerateNymRequest_OneofMarshaler, _GenerateNymRequest_OneofUnmarshaler, _GenerateNymRequest_OneofSizer, []interface{}{
		(*GenerateNymRequest_ProofRandData)(nil),
		(*GenerateNymRequest_ProofData)(nil),
	}
}

func _GenerateNymRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GenerateNymRequest)
	// type
	switch x := m.Type.(type) {
	case *GenerateNymRequest_ProofRandData:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProofRandData); err != nil {
			return err
		}
	case *GenerateNymRequest_ProofData:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.ProofData)
	case nil:
	default:
		return fmt.Errorf("GenerateNymRequest.Type has unexpected type %T", x)
	}
	return nil
}

func _GenerateNymRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GenerateNymRequest)
	switch tag {
	case 1: // type.proofRandData
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GenerateNymProofRandData)
		err := b.DecodeMessage(msg)
		m.Type = &GenerateNymRequest_ProofRandData{msg}
		return true, err
	case 2: // type.proofData
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Type = &GenerateNymRequest_ProofData{x}
		return true, err
	default:
		return false, nil
	}
}

func _GenerateNymRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GenerateNymRequest)
	// type
	switch x := m.Type.(type) {
	case *GenerateNymRequest_ProofRandData:
		s := proto.Size(x.ProofRandData)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GenerateNymRequest_ProofData:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ProofData)))
		n += len(x.ProofData)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GenerateNymResponse struct {
	// Types that are valid to be assigned to Type:
	//	*GenerateNymResponse_Decommitment
	//	*GenerateNymResponse_Success
	Type isGenerateNymResponse_Type `protobuf_oneof:"type"`
}

func (m *GenerateNymResponse) Reset()                    { *m = GenerateNymResponse{} }
func (m *GenerateNymResponse) String() string            { return proto.CompactTextString(m) }
func (*GenerateNymResponse) ProtoMessage()               {}
func (*GenerateNymResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type isGenerateNymResponse_Type interface {
	isGenerateNymResponse_Type()
}

type GenerateNymResponse_Decommitment struct {
	Decommitment *PedersenDecommitment `protobuf:"bytes,1,opt,name=decommitment,oneof"`
}
type GenerateNymResponse_Success struct {
	Success bool `protobuf:"varint,2,opt,name=success,oneof"`
}

func (*GenerateNymResponse_Decommitment) isGenerateNymResponse_Type() {}
func (*GenerateNymResponse_Success) isGenerateNymResponse_Type()      {}

func (m *GenerateNymResponse) GetType() isGenerateNymResponse_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *GenerateNymResponse) GetDecommitment() *PedersenDecommitment {
	if x, ok := m.GetType().(*GenerateNymResponse_Decommitment); ok {
		return x.Decommitment
	}
	return nil
}

func (m *GenerateNymResponse) GetSuccess() bool {
	if x, ok := m.GetType().(*GenerateNymResponse_Success); ok {
		return x.Success
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GenerateNymResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GenerateNymResponse_OneofMarshaler, _GenerateNymResponse_OneofUnmarshaler, _GenerateNymResponse_OneofSizer, []interface{}{
		(*GenerateNymResponse_Decommitment)(nil),
		(*GenerateNymResponse_Success)(nil),
	}
}

func _GenerateNymResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GenerateNymResponse)
	// type
	switch x := m.Type.(type) {
	case *GenerateNymResponse_Decommitment:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Decommitment); err != nil {
			return err
		}
	case *GenerateNymResponse_Success:
		t := uint64(0)
		if x.Success {
			t = 1
		}
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("GenerateNymResponse.Type has unexpected type %T", x)
	}
	return nil
}

func _GenerateNymResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GenerateNymResponse)
	switch tag {
	case 1: // type.decommitment
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PedersenDecommitment)
		err := b.DecodeMessage(msg)
		m.Type = &GenerateNymResponse_Decommitment{msg}
		return true, err
	case 2: // type.success
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &GenerateNymResponse_Success{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _GenerateNymResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GenerateNymResponse)
	// type
	switch x := m.Type.(type) {
	case *GenerateNymResponse_Decommitment:
		s := proto.Size(x.Decommitment)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GenerateNymResponse_Success:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ObtainCredRequest struct {
	// Types that are valid to be assigned to Type:
	//	*ObtainCredRequest_ProofRandData
	//	*ObtainCredRequest_ProofData
	//	*ObtainCredRequest_Challenge
	Type isObtainCredRequest_Type `protobuf_oneof:"type"`
}

func (m *ObtainCredRequest) Reset()                    { *m = ObtainCredRequest{} }
func (m *ObtainCredRequest) String() string            { return proto.CompactTextString(m) }
func (*ObtainCredRequest) ProtoMessage()               {}
func (*ObtainCredRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isObtainCredRequest_Type interface {
	isObtainCredRequest_Type()
}

type ObtainCredRequest_ProofRandData struct {
	ProofRandData *ProofRandData `protobuf:"bytes,1,opt,name=proofRandData,oneof"`
}
type ObtainCredRequest_ProofData struct {
	ProofData []byte `protobuf:"bytes,2,opt,name=proofData,proto3,oneof"`
}
type ObtainCredRequest_Challenge struct {
	Challenge *BytesPair `protobuf:"bytes,3,opt,name=challenge,oneof"`
}

func (*ObtainCredRequest_ProofRandData) isObtainCredRequest_Type() {}
func (*ObtainCredRequest_ProofData) isObtainCredRequest_Type()     {}
func (*ObtainCredRequest_Challenge) isObtainCredRequest_Type()     {}

func (m *ObtainCredRequest) GetType() isObtainCredRequest_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *ObtainCredRequest) GetProofRandData() *ProofRandData {
	if x, ok := m.GetType().(*ObtainCredRequest_ProofRandData); ok {
		return x.ProofRandData
	}
	return nil
}

func (m *ObtainCredRequest) GetProofData() []byte {
	if x, ok := m.GetType().(*ObtainCredRequest_ProofData); ok {
		return x.ProofData
	}
	return nil
}

func (m *ObtainCredRequest) GetChallenge() *BytesPair {
	if x, ok := m.GetType().(*ObtainCredRequest_Challenge); ok {
		return x.Challenge
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ObtainCredRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ObtainCredRequest_OneofMarshaler, _ObtainCredRequest_OneofUnmarshaler, _ObtainCredRequest_OneofSizer, []interface{}{
		(*ObtainCredRequest_ProofRandData)(nil),
		(*ObtainCredRequest_ProofData)(nil),
		(*ObtainCredRequest_Challenge)(nil),
	}
}

func _ObtainCredRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ObtainCredRequest)
	// type
	switch x := m.Type.(type) {
	case *ObtainCredRequest_ProofRandData:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProofRandData); err != nil {
			return err
		}
	case *ObtainCredRequest_ProofData:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.ProofData)
	case *ObtainCredRequest_Challenge:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Challenge); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ObtainCredRequest.Type has unexpected type %T", x)
	}
	return nil
}

func _ObtainCredRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ObtainCredRequest)
	switch tag {
	case 1: // type.proofRandData
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ProofRandData)
		err := b.DecodeMessage(msg)
		m.Type = &ObtainCredRequest_ProofRandData{msg}
		return true, err
	case 2: // type.proofData
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Type = &ObtainCredRequest_ProofData{x}
		return true, err
	case 3: // type.challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BytesPair)
		err := b.DecodeMessage(msg)
		m.Type = &ObtainCredRequest_Challenge{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ObtainCredRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ObtainCredRequest)
	// type
	switch x := m.Type.(type) {
	case *ObtainCredRequest_ProofRandData:
		s := proto.Size(x.ProofRandData)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObtainCredRequest_ProofData:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ProofData)))
		n += len(x.ProofData)
	case *ObtainCredRequest_Challenge:
		s := proto.Size(x.Challenge)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ObtainCredResponse struct {
	// Types that are valid to be assigned to Type:
	//	*ObtainCredResponse_Challenge
	//	*ObtainCredResponse_ProofRandData
	//	*ObtainCredResponse_ProofData
	Type isObtainCredResponse_Type `protobuf_oneof:"type"`
}

func (m *ObtainCredResponse) Reset()                    { *m = ObtainCredResponse{} }
func (m *ObtainCredResponse) String() string            { return proto.CompactTextString(m) }
func (*ObtainCredResponse) ProtoMessage()               {}
func (*ObtainCredResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isObtainCredResponse_Type interface {
	isObtainCredResponse_Type()
}

type ObtainCredResponse_Challenge struct {
	Challenge []byte `protobuf:"bytes,1,opt,name=challenge,proto3,oneof"`
}
type ObtainCredResponse_ProofRandData struct {
	ProofRandData *ObtainCredProofRandData `protobuf:"bytes,2,opt,name=proofRandData,oneof"`
}
type ObtainCredResponse_ProofData struct {
	ProofData *BytesPair `protobuf:"bytes,3,opt,name=proofData,oneof"`
}

func (*ObtainCredResponse_Challenge) isObtainCredResponse_Type()     {}
func (*ObtainCredResponse_ProofRandData) isObtainCredResponse_Type() {}
func (*ObtainCredResponse_ProofData) isObtainCredResponse_Type()     {}

func (m *ObtainCredResponse) GetType() isObtainCredResponse_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *ObtainCredResponse) GetChallenge() []byte {
	if x, ok := m.GetType().(*ObtainCredResponse_Challenge); ok {
		return x.Challenge
	}
	return nil
}

func (m *ObtainCredResponse) GetProofRandData() *ObtainCredProofRandData {
	if x, ok := m.GetType().(*ObtainCredResponse_ProofRandData); ok {
		return x.ProofRandData
	}
	return nil
}

func (m *ObtainCredResponse) GetProofData() *BytesPair {
	if x, ok := m.GetType().(*ObtainCredResponse_ProofData); ok {
		return x.ProofData
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ObtainCredResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ObtainCredResponse_OneofMarshaler, _ObtainCredResponse_OneofUnmarshaler, _ObtainCredResponse_OneofSizer, []interface{}{
		(*ObtainCredResponse_Challenge)(nil),
		(*ObtainCredResponse_ProofRandData)(nil),
		(*ObtainCredResponse_ProofData)(nil),
	}
}

func _ObtainCredResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ObtainCredResponse)
	// type
	switch x := m.Type.(type) {
	case *ObtainCredResponse_Challenge:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Challenge)
	case *ObtainCredResponse_ProofRandData:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProofRandData); err != nil {
			return err
		}
	case *ObtainCredResponse_ProofData:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProofData); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ObtainCredResponse.Type has unexpected type %T", x)
	}
	return nil
}

func _ObtainCredResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ObtainCredResponse)
	switch tag {
	case 1: // type.challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Type = &ObtainCredResponse_Challenge{x}
		return true, err
	case 2: // type.proofRandData
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ObtainCredProofRandData)
		err := b.DecodeMessage(msg)
		m.Type = &ObtainCredResponse_ProofRandData{msg}
		return true, err
	case 3: // type.proofData
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BytesPair)
		err := b.DecodeMessage(msg)
		m.Type = &ObtainCredResponse_ProofData{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ObtainCredResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ObtainCredResponse)
	// type
	switch x := m.Type.(type) {
	case *ObtainCredResponse_Challenge:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Challenge)))
		n += len(x.Challenge)
	case *ObtainCredResponse_ProofRandData:
		s := proto.Size(x.ProofRandData)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObtainCredResponse_ProofData:
		s := proto.Size(x.ProofData)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TransferCredRequest struct {
	// Types that are valid to be assigned to Type:
	//	*TransferCredRequest_ProofRandData
	//	*TransferCredRequest_ProofData
	Type isTransferCredRequest_Type `protobuf_oneof:"type"`
}

func (m *TransferCredRequest) Reset()                    { *m = TransferCredRequest{} }
func (m *TransferCredRequest) String() string            { return proto.CompactTextString(m) }
func (*TransferCredRequest) ProtoMessage()               {}
func (*TransferCredRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isTransferCredRequest_Type interface {
	isTransferCredRequest_Type()
}

type TransferCredRequest_ProofRandData struct {
	ProofRandData *TransferCredProofRandData `protobuf:"bytes,1,opt,name=proofRandData,oneof"`
}
type TransferCredRequest_ProofData struct {
	ProofData []byte `protobuf:"bytes,2,opt,name=proofData,proto3,oneof"`
}

func (*TransferCredRequest_ProofRandData) isTransferCredRequest_Type() {}
func (*TransferCredRequest_ProofData) isTransferCredRequest_Type()     {}

func (m *TransferCredRequest) GetType() isTransferCredRequest_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *TransferCredRequest) GetProofRandData() *TransferCredProofRandData {
	if x, ok := m.GetType().(*TransferCredRequest_ProofRandData); ok {
		return x.ProofRandData
	}
	return nil
}

func (m *TransferCredRequest) GetProofData() []byte {
	if x, ok := m.GetType().(*TransferCredRequest_ProofData); ok {
		return x.ProofData
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TransferCredRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TransferCredRequest_OneofMarshaler, _TransferCredRequest_OneofUnmarshaler, _TransferCredRequest_OneofSizer, []interface{}{
		(*TransferCredRequest_ProofRandData)(nil),
		(*TransferCredRequest_ProofData)(nil),
	}
}

func _TransferCredRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TransferCredRequest)
	// type
	switch x := m.Type.(type) {
	case *TransferCredRequest_ProofRandData:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProofRandData); err != nil {
			return err
		}
	case *TransferCredRequest_ProofData:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.ProofData)
	case nil:
	default:
		return fmt.Errorf("TransferCredRequest.Type has unexpected type %T", x)
	}
	return nil
}

func _TransferCredRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TransferCredRequest)
	switch tag {
	case 1: // type.proofRandData
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TransferCredProofRandData)
		err := b.DecodeMessage(msg)
		m.Type = &TransferCredRequest_ProofRandData{msg}
		return true, err
	case 2: // type.proofData
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Type = &TransferCredRequest_ProofData{x}
		return true, err
	default:
		return false, nil
	}
}

func _TransferCredRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TransferCredRequest)
	// type
	switch x := m.Type.(type) {
	case *TransferCredRequest_ProofRandData:
		s := proto.Size(x.ProofRandData)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TransferCredRequest_ProofData:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ProofData)))
		n += len(x.ProofData)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TransferCredResponse struct {
	// Types that are valid to be assigned to Type:
	//	*TransferCredResponse_Challenge
	//	*TransferCredResponse_SessionKey
	Type isTransferCredResponse_Type `protobuf_oneof:"type"`
}

func (m *TransferCredResponse) Reset()                    { *m = TransferCredResponse{} }
func (m *TransferCredResponse) String() string            { return proto.CompactTextString(m) }
func (*TransferCredResponse) ProtoMessage()               {}
func (*TransferCredResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isTransferCredResponse_Type interface {
	isTransferCredResponse_Type()
}

type TransferCredResponse_Challenge struct {
	Challenge []byte `protobuf:"bytes,1,opt,name=challenge,proto3,oneof"`
}
type TransferCredResponse_SessionKey struct {
	SessionKey string `protobuf:"bytes,2,opt,name=sessionKey,oneof"`
}

func (*TransferCredResponse_Challenge) isTransferCredResponse_Type()  {}
func (*TransferCredResponse_SessionKey) isTransferCredResponse_Type() {}

func (m *TransferCredResponse) GetType() isTransferCredResponse_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *TransferCredResponse) GetChallenge() []byte {
	if x, ok := m.GetType().(*TransferCredResponse_Challenge); ok {
		return x.Challenge
	}
	return nil
}

func (m *TransferCredResponse) GetSessionKey() string {
	if x, ok := m.GetType().(*TransferCredResponse_SessionKey); ok {
		return x.SessionKey
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TransferCredResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TransferCredResponse_OneofMarshaler, _TransferCredResponse_OneofUnmarshaler, _TransferCredResponse_OneofSizer, []interface{}{
		(*TransferCredResponse_Challenge)(nil),
		(*TransferCredResponse_SessionKey)(nil),
	}
}

func _TransferCredResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TransferCredResponse)
	// type
	switch x := m.Type.(type) {
	case *TransferCredResponse_Challenge:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Challenge)
	case *TransferCredResponse_SessionKey:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.SessionKey)
	case nil:
	default:
		return fmt.Errorf("TransferCredResponse.Type has unexpected type %T", x)
	}
	return nil
}

func _TransferCredResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TransferCredResponse)
	switch tag {
	case 1: // type.challenge
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Type = &TransferCredResponse_Challenge{x}
		return true, err
	case 2: // type.sessionKey
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Type = &TransferCredResponse_SessionKey{x}
		return true, err
	default:
		return false, nil
	}
}

func _TransferCredResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TransferCredResponse)
	// type
	switch x := m.Type.(type) {
	case *TransferCredResponse_Challenge:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Challenge)))
		n += len(x.Challenge)
	case *TransferCredResponse_SessionKey:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.SessionKey)))
		n += len(x.SessionKey)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GenerateNymProofRandData struct {
	X1     []byte `protobuf:"bytes,1,opt,name=X1,proto3" json:"X1,omitempty"`
	A1     []byte `protobuf:"bytes,2,opt,name=A1,proto3" json:"A1,omitempty"`
	B1     []byte `protobuf:"bytes,3,opt,name=B1,proto3" json:"B1,omitempty"`
	X2     []byte `protobuf:"bytes,4,opt,name=X2,proto3" json:"X2,omitempty"`
	A2     []byte `protobuf:"bytes,5,opt,name=A2,proto3" json:"A2,omitempty"`
	B2     []byte `protobuf:"bytes,6,opt,name=B2,proto3" json:"B2,omitempty"`
	R      []byte `protobuf:"bytes,7,opt,name=R,proto3" json:"R,omitempty"`
	S      []byte `protobuf:"bytes,8,opt,name=S,proto3" json:"S,omitempty"`
	RegKey string `protobuf:"bytes,9,opt,name=regKey" json:"regKey,omitempty"`
}

func (m *GenerateNymProofRandData) Reset()                    { *m = GenerateNymProofRandData{} }
func (m *GenerateNymProofRandData) String() string            { return proto.CompactTextString(m) }
func (*GenerateNymProofRandData) ProtoMessage()               {}
func (*GenerateNymProofRandData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *GenerateNymProofRandData) GetX1() []byte {
	if m != nil {
		return m.X1
	}
	return nil
}

func (m *GenerateNymProofRandData) GetA1() []byte {
	if m != nil {
		return m.A1
	}
	return nil
}

func (m *GenerateNymProofRandData) GetB1() []byte {
	if m != nil {
		return m.B1
	}
	return nil
}

func (m *GenerateNymProofRandData) GetX2() []byte {
	if m != nil {
		return m.X2
	}
	return nil
}

func (m *GenerateNymProofRandData) GetA2() []byte {
	if m != nil {
		return m.A2
	}
	return nil
}

func (m *GenerateNymProofRandData) GetB2() []byte {
	if m != nil {
		return m.B2
	}
	return nil
}

func (m *GenerateNymProofRandData) GetR() []byte {
	if m != nil {
		return m.R
	}
	return nil
}

func (m *GenerateNymProofRandData) GetS() []byte {
	if m != nil {
		return m.S
	}
	return nil
}

func (m *GenerateNymProofRandData) GetRegKey() string {
	if m != nil {
		return m.RegKey
	}
	return ""
}

type BytesPair struct {
	X []byte `protobuf:"bytes,1,opt,name=x,proto3" json:"x,omitempty"`
	Y []byte `protobuf:"bytes,2,opt,name=y,proto3" json:"y,omitempty"`
}

func (m *BytesPair) Reset()                    { *m = BytesPair{} }
func (m *BytesPair) String() string            { return proto.CompactTextString(m) }
func (*BytesPair) ProtoMessage()               {}
func (*BytesPair) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *BytesPair) GetX() []byte {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *BytesPair) GetY() []byte {
	if m != nil {
		return m.Y
	}
	return nil
}

// TODO remove?
type PedersenDecommitment struct {
	X []byte `protobuf:"bytes,1,opt,name=X,proto3" json:"X,omitempty"`
	R []byte `protobuf:"bytes,2,opt,name=R,proto3" json:"R,omitempty"`
}

func (m *PedersenDecommitment) Reset()                    { *m = PedersenDecommitment{} }
func (m *PedersenDecommitment) String() string            { return proto.CompactTextString(m) }
func (*PedersenDecommitment) ProtoMessage()               {}
func (*PedersenDecommitment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *PedersenDecommitment) GetX() []byte {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *PedersenDecommitment) GetR() []byte {
	if m != nil {
		return m.R
	}
	return nil
}

type Cred struct {
	SmallAToGamma []byte      `protobuf:"bytes,1,opt,name=SmallAToGamma,proto3" json:"SmallAToGamma,omitempty"`
	SmallBToGamma []byte      `protobuf:"bytes,2,opt,name=SmallBToGamma,proto3" json:"SmallBToGamma,omitempty"`
	AToGamma      []byte      `protobuf:"bytes,3,opt,name=AToGamma,proto3" json:"AToGamma,omitempty"`
	BToGamma      []byte      `protobuf:"bytes,4,opt,name=BToGamma,proto3" json:"BToGamma,omitempty"`
	T1            *Transcript `protobuf:"bytes,5,opt,name=T1" json:"T1,omitempty"`
	T2            *Transcript `protobuf:"bytes,6,opt,name=T2" json:"T2,omitempty"`
}

func (m *Cred) Reset()                    { *m = Cred{} }
func (m *Cred) String() string            { return proto.CompactTextString(m) }
func (*Cred) ProtoMessage()               {}
func (*Cred) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Cred) GetSmallAToGamma() []byte {
	if m != nil {
		return m.SmallAToGamma
	}
	return nil
}

func (m *Cred) GetSmallBToGamma() []byte {
	if m != nil {
		return m.SmallBToGamma
	}
	return nil
}

func (m *Cred) GetAToGamma() []byte {
	if m != nil {
		return m.AToGamma
	}
	return nil
}

func (m *Cred) GetBToGamma() []byte {
	if m != nil {
		return m.BToGamma
	}
	return nil
}

func (m *Cred) GetT1() *Transcript {
	if m != nil {
		return m.T1
	}
	return nil
}

func (m *Cred) GetT2() *Transcript {
	if m != nil {
		return m.T2
	}
	return nil
}

type Transcript struct {
	A      []byte `protobuf:"bytes,1,opt,name=A,proto3" json:"A,omitempty"`
	B      []byte `protobuf:"bytes,2,opt,name=B,proto3" json:"B,omitempty"`
	Hash   []byte `protobuf:"bytes,3,opt,name=Hash,proto3" json:"Hash,omitempty"`
	ZAlpha []byte `protobuf:"bytes,4,opt,name=ZAlpha,proto3" json:"ZAlpha,omitempty"`
}

func (m *Transcript) Reset()                    { *m = Transcript{} }
func (m *Transcript) String() string            { return proto.CompactTextString(m) }
func (*Transcript) ProtoMessage()               {}
func (*Transcript) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Transcript) GetA() []byte {
	if m != nil {
		return m.A
	}
	return nil
}

func (m *Transcript) GetB() []byte {
	if m != nil {
		return m.B
	}
	return nil
}

func (m *Transcript) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *Transcript) GetZAlpha() []byte {
	if m != nil {
		return m.ZAlpha
	}
	return nil
}

type ObtainCredProofRandData struct {
	X11 []byte `protobuf:"bytes,1,opt,name=X11,proto3" json:"X11,omitempty"`
	X12 []byte `protobuf:"bytes,2,opt,name=X12,proto3" json:"X12,omitempty"`
	X21 []byte `protobuf:"bytes,3,opt,name=X21,proto3" json:"X21,omitempty"`
	X22 []byte `protobuf:"bytes,4,opt,name=X22,proto3" json:"X22,omitempty"`
	A   []byte `protobuf:"bytes,5,opt,name=A,proto3" json:"A,omitempty"`
	B   []byte `protobuf:"bytes,6,opt,name=B,proto3" json:"B,omitempty"`
}

func (m *ObtainCredProofRandData) Reset()                    { *m = ObtainCredProofRandData{} }
func (m *ObtainCredProofRandData) String() string            { return proto.CompactTextString(m) }
func (*ObtainCredProofRandData) ProtoMessage()               {}
func (*ObtainCredProofRandData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ObtainCredProofRandData) GetX11() []byte {
	if m != nil {
		return m.X11
	}
	return nil
}

func (m *ObtainCredProofRandData) GetX12() []byte {
	if m != nil {
		return m.X12
	}
	return nil
}

func (m *ObtainCredProofRandData) GetX21() []byte {
	if m != nil {
		return m.X21
	}
	return nil
}

func (m *ObtainCredProofRandData) GetX22() []byte {
	if m != nil {
		return m.X22
	}
	return nil
}

func (m *ObtainCredProofRandData) GetA() []byte {
	if m != nil {
		return m.A
	}
	return nil
}

func (m *ObtainCredProofRandData) GetB() []byte {
	if m != nil {
		return m.B
	}
	return nil
}

type TransferCredProofRandData struct {
	OrgName string `protobuf:"bytes,1,opt,name=OrgName" json:"OrgName,omitempty"`
	X1      []byte `protobuf:"bytes,2,opt,name=X1,proto3" json:"X1,omitempty"`
	X2      []byte `protobuf:"bytes,3,opt,name=X2,proto3" json:"X2,omitempty"`
	NymA    []byte `protobuf:"bytes,4,opt,name=NymA,proto3" json:"NymA,omitempty"`
	NymB    []byte `protobuf:"bytes,5,opt,name=NymB,proto3" json:"NymB,omitempty"`
	Cred    *Cred  `protobuf:"bytes,6,opt,name=cred" json:"cred,omitempty"`
}

func (m *TransferCredProofRandData) Reset()                    { *m = TransferCredProofRandData{} }
func (m *TransferCredProofRandData) String() string            { return proto.CompactTextString(m) }
func (*TransferCredProofRandData) ProtoMessage()               {}
func (*TransferCredProofRandData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *TransferCredProofRandData) GetOrgName() string {
	if m != nil {
		return m.OrgName
	}
	return ""
}

func (m *TransferCredProofRandData) GetX1() []byte {
	if m != nil {
		return m.X1
	}
	return nil
}

func (m *TransferCredProofRandData) GetX2() []byte {
	if m != nil {
		return m.X2
	}
	return nil
}

func (m *TransferCredProofRandData) GetNymA() []byte {
	if m != nil {
		return m.NymA
	}
	return nil
}

func (m *TransferCredProofRandData) GetNymB() []byte {
	if m != nil {
		return m.NymB
	}
	return nil
}

func (m *TransferCredProofRandData) GetCred() *Cred {
	if m != nil {
		return m.Cred
	}
	return nil
}

func init() {
	proto.RegisterType((*CARequest)(nil), "psyspb.CARequest")
	proto.RegisterType((*CAResponse)(nil), "psyspb.CAResponse")
	proto.RegisterType((*ProofRandData)(nil), "psyspb.ProofRandData")
	proto.RegisterType((*Cert)(nil), "psyspb.Cert")
	proto.RegisterType((*GenerateNymRequest)(nil), "psyspb.GenerateNymRequest")
	proto.RegisterType((*GenerateNymResponse)(nil), "psyspb.GenerateNymResponse")
	proto.RegisterType((*ObtainCredRequest)(nil), "psyspb.ObtainCredRequest")
	proto.RegisterType((*ObtainCredResponse)(nil), "psyspb.ObtainCredResponse")
	proto.RegisterType((*TransferCredRequest)(nil), "psyspb.TransferCredRequest")
	proto.RegisterType((*TransferCredResponse)(nil), "psyspb.TransferCredResponse")
	proto.RegisterType((*GenerateNymProofRandData)(nil), "psyspb.GenerateNymProofRandData")
	proto.RegisterType((*BytesPair)(nil), "psyspb.BytesPair")
	proto.RegisterType((*PedersenDecommitment)(nil), "psyspb.PedersenDecommitment")
	proto.RegisterType((*Cred)(nil), "psyspb.Cred")
	proto.RegisterType((*Transcript)(nil), "psyspb.Transcript")
	proto.RegisterType((*ObtainCredProofRandData)(nil), "psyspb.ObtainCredProofRandData")
	proto.RegisterType((*TransferCredProofRandData)(nil), "psyspb.TransferCredProofRandData")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for CA service

type CAClient interface {
	GenerateCertificate(ctx context.Context, opts ...grpc.CallOption) (CA_GenerateCertificateClient, error)
}

type cAClient struct {
	cc *grpc.ClientConn
}

func NewCAClient(cc *grpc.ClientConn) CAClient {
	return &cAClient{cc}
}

func (c *cAClient) GenerateCertificate(ctx context.Context, opts ...grpc.CallOption) (CA_GenerateCertificateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CA_serviceDesc.Streams[0], c.cc, "/psyspb.CA/GenerateCertificate", opts...)
	if err != nil {
		return nil, err
	}
	x := &cAGenerateCertificateClient{stream}
	return x, nil
}

type CA_GenerateCertificateClient interface {
	Send(*CARequest) error
	Recv() (*CAResponse, error)
	grpc.ClientStream
}

type cAGenerateCertificateClient struct {
	grpc.ClientStream
}

func (x *cAGenerateCertificateClient) Send(m *CARequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *cAGenerateCertificateClient) Recv() (*CAResponse, error) {
	m := new(CAResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for CA service

type CAServer interface {
	GenerateCertificate(CA_GenerateCertificateServer) error
}

func RegisterCAServer(s *grpc.Server, srv CAServer) {
	s.RegisterService(&_CA_serviceDesc, srv)
}

func _CA_GenerateCertificate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CAServer).GenerateCertificate(&cAGenerateCertificateServer{stream})
}

type CA_GenerateCertificateServer interface {
	Send(*CAResponse) error
	Recv() (*CARequest, error)
	grpc.ServerStream
}

type cAGenerateCertificateServer struct {
	grpc.ServerStream
}

func (x *cAGenerateCertificateServer) Send(m *CAResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *cAGenerateCertificateServer) Recv() (*CARequest, error) {
	m := new(CARequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _CA_serviceDesc = grpc.ServiceDesc{
	ServiceName: "psyspb.CA",
	HandlerType: (*CAServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GenerateCertificate",
			Handler:       _CA_GenerateCertificate_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "anauth/psys/psyspb/psys.proto",
}

// Client API for Org service

type OrgClient interface {
	GenerateNym(ctx context.Context, opts ...grpc.CallOption) (Org_GenerateNymClient, error)
	ObtainCred(ctx context.Context, opts ...grpc.CallOption) (Org_ObtainCredClient, error)
	TransferCred(ctx context.Context, opts ...grpc.CallOption) (Org_TransferCredClient, error)
}

type orgClient struct {
	cc *grpc.ClientConn
}

func NewOrgClient(cc *grpc.ClientConn) OrgClient {
	return &orgClient{cc}
}

func (c *orgClient) GenerateNym(ctx context.Context, opts ...grpc.CallOption) (Org_GenerateNymClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Org_serviceDesc.Streams[0], c.cc, "/psyspb.Org/GenerateNym", opts...)
	if err != nil {
		return nil, err
	}
	x := &orgGenerateNymClient{stream}
	return x, nil
}

type Org_GenerateNymClient interface {
	Send(*GenerateNymRequest) error
	Recv() (*GenerateNymResponse, error)
	grpc.ClientStream
}

type orgGenerateNymClient struct {
	grpc.ClientStream
}

func (x *orgGenerateNymClient) Send(m *GenerateNymRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *orgGenerateNymClient) Recv() (*GenerateNymResponse, error) {
	m := new(GenerateNymResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *orgClient) ObtainCred(ctx context.Context, opts ...grpc.CallOption) (Org_ObtainCredClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Org_serviceDesc.Streams[1], c.cc, "/psyspb.Org/ObtainCred", opts...)
	if err != nil {
		return nil, err
	}
	x := &orgObtainCredClient{stream}
	return x, nil
}

type Org_ObtainCredClient interface {
	Send(*ObtainCredRequest) error
	Recv() (*ObtainCredResponse, error)
	grpc.ClientStream
}

type orgObtainCredClient struct {
	grpc.ClientStream
}

func (x *orgObtainCredClient) Send(m *ObtainCredRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *orgObtainCredClient) Recv() (*ObtainCredResponse, error) {
	m := new(ObtainCredResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *orgClient) TransferCred(ctx context.Context, opts ...grpc.CallOption) (Org_TransferCredClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Org_serviceDesc.Streams[2], c.cc, "/psyspb.Org/TransferCred", opts...)
	if err != nil {
		return nil, err
	}
	x := &orgTransferCredClient{stream}
	return x, nil
}

type Org_TransferCredClient interface {
	Send(*TransferCredRequest) error
	Recv() (*TransferCredResponse, error)
	grpc.ClientStream
}

type orgTransferCredClient struct {
	grpc.ClientStream
}

func (x *orgTransferCredClient) Send(m *TransferCredRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *orgTransferCredClient) Recv() (*TransferCredResponse, error) {
	m := new(TransferCredResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Org service

type OrgServer interface {
	GenerateNym(Org_GenerateNymServer) error
	ObtainCred(Org_ObtainCredServer) error
	TransferCred(Org_TransferCredServer) error
}

func RegisterOrgServer(s *grpc.Server, srv OrgServer) {
	s.RegisterService(&_Org_serviceDesc, srv)
}

func _Org_GenerateNym_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OrgServer).GenerateNym(&orgGenerateNymServer{stream})
}

type Org_GenerateNymServer interface {
	Send(*GenerateNymResponse) error
	Recv() (*GenerateNymRequest, error)
	grpc.ServerStream
}

type orgGenerateNymServer struct {
	grpc.ServerStream
}

func (x *orgGenerateNymServer) Send(m *GenerateNymResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *orgGenerateNymServer) Recv() (*GenerateNymRequest, error) {
	m := new(GenerateNymRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Org_ObtainCred_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OrgServer).ObtainCred(&orgObtainCredServer{stream})
}

type Org_ObtainCredServer interface {
	Send(*ObtainCredResponse) error
	Recv() (*ObtainCredRequest, error)
	grpc.ServerStream
}

type orgObtainCredServer struct {
	grpc.ServerStream
}

func (x *orgObtainCredServer) Send(m *ObtainCredResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *orgObtainCredServer) Recv() (*ObtainCredRequest, error) {
	m := new(ObtainCredRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Org_TransferCred_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OrgServer).TransferCred(&orgTransferCredServer{stream})
}

type Org_TransferCredServer interface {
	Send(*TransferCredResponse) error
	Recv() (*TransferCredRequest, error)
	grpc.ServerStream
}

type orgTransferCredServer struct {
	grpc.ServerStream
}

func (x *orgTransferCredServer) Send(m *TransferCredResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *orgTransferCredServer) Recv() (*TransferCredRequest, error) {
	m := new(TransferCredRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Org_serviceDesc = grpc.ServiceDesc{
	ServiceName: "psyspb.Org",
	HandlerType: (*OrgServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GenerateNym",
			Handler:       _Org_GenerateNym_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ObtainCred",
			Handler:       _Org_ObtainCred_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "TransferCred",
			Handler:       _Org_TransferCred_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "anauth/psys/psyspb/psys.proto",
}

func init() { proto.RegisterFile("anauth/psys/psyspb/psys.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 884 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xbc, 0x56, 0xcd, 0x4e, 0xe3, 0x56,
	0x14, 0xc6, 0x49, 0x08, 0xe4, 0x24, 0x54, 0xe5, 0x42, 0xdb, 0x10, 0x68, 0x4b, 0xad, 0x4a, 0x45,
	0x55, 0x15, 0x1a, 0x77, 0xd5, 0x45, 0x17, 0x76, 0x90, 0x48, 0xd5, 0x0a, 0x90, 0xc9, 0x22, 0x62,
	0x55, 0xc7, 0xb9, 0x24, 0x56, 0x63, 0xc7, 0xb5, 0x1d, 0x09, 0x57, 0x9a, 0xed, 0x68, 0xde, 0x62,
	0x9e, 0x60, 0x66, 0x3d, 0xcf, 0x31, 0x2f, 0x32, 0xaf, 0x30, 0xf7, 0x3f, 0xd7, 0x13, 0x67, 0x86,
	0x05, 0x9a, 0x0d, 0x9c, 0xdf, 0xef, 0x7e, 0x3e, 0xf7, 0x9c, 0x73, 0x03, 0xdf, 0x7a, 0x91, 0xb7,
	0xcc, 0x66, 0xe7, 0x71, 0x9a, 0xa7, 0xec, 0x4f, 0x3c, 0x66, 0xff, 0xba, 0x71, 0xb2, 0xc8, 0x16,
	0xa8, 0xce, 0x4d, 0x66, 0x02, 0x8d, 0xbe, 0xed, 0xe2, 0xff, 0x96, 0x38, 0xcd, 0xd0, 0x1f, 0xb0,
	0x47, 0xbc, 0x8b, 0x7b, 0xd7, 0x8b, 0x26, 0x17, 0x5e, 0xe6, 0xb5, 0x8d, 0x53, 0xe3, 0xac, 0x69,
	0x7d, 0xd5, 0xe5, 0xc1, 0xdd, 0x1b, 0xdd, 0x39, 0xd8, 0x72, 0x8b, 0xd1, 0xe8, 0x3b, 0x68, 0x30,
	0x03, 0x4b, 0xad, 0x90, 0xd4, 0x16, 0x89, 0x59, 0x99, 0x9c, 0x3a, 0xd4, 0xb2, 0x3c, 0xc6, 0xe6,
	0x08, 0x80, 0x9e, 0x99, 0xc6, 0x8b, 0x28, 0xc5, 0x34, 0xcb, 0x9f, 0x79, 0xf3, 0x39, 0x8e, 0xa6,
	0x98, 0x1d, 0xc8, 0xb2, 0x94, 0x09, 0x99, 0x50, 0xf3, 0x71, 0x92, 0x31, 0xc0, 0xa6, 0xd5, 0x92,
	0x5c, 0xfa, 0xc4, 0x46, 0x02, 0x99, 0x4f, 0x21, 0xff, 0x0e, 0x7b, 0x05, 0x8e, 0xa8, 0x05, 0xc6,
	0x88, 0x83, 0xba, 0xc6, 0x88, 0x6a, 0x36, 0x27, 0xe6, 0x1a, 0x36, 0xd5, 0x9c, 0x76, 0x95, 0x6b,
	0x8e, 0x79, 0x07, 0x35, 0x0a, 0x89, 0x3a, 0xb0, 0xeb, 0xcc, 0x83, 0x68, 0x82, 0x27, 0xb6, 0x48,
	0x54, 0xba, 0xe6, 0x73, 0x04, 0x8c, 0xd2, 0x29, 0x9a, 0x2b, 0xd1, 0x5c, 0xaa, 0xdd, 0xb6, 0x6b,
	0x5c, 0xbb, 0x35, 0x9f, 0x1b, 0x80, 0x2e, 0x71, 0x84, 0x13, 0x2f, 0xc3, 0x57, 0x79, 0x28, 0xcb,
	0x3d, 0x28, 0x2f, 0xf7, 0xa9, 0xfc, 0x44, 0x2d, 0xe5, 0x89, 0x2a, 0xff, 0x0c, 0x0e, 0x0a, 0x3c,
	0xc4, 0x15, 0x38, 0xd0, 0x9a, 0x60, 0x7f, 0x11, 0x86, 0x41, 0x16, 0xe2, 0x28, 0x13, 0x3c, 0x4e,
	0xd4, 0xb5, 0xe3, 0x09, 0x4e, 0x52, 0x1c, 0x5d, 0x68, 0x31, 0x04, 0xbf, 0x90, 0x43, 0x6a, 0xb3,
	0x93, 0x2e, 0x7d, 0x1f, 0xa7, 0x29, 0x23, 0xb0, 0x4b, 0x02, 0xa4, 0x41, 0x1d, 0xff, 0xca, 0x80,
	0xfd, 0xeb, 0x71, 0xe6, 0x05, 0x51, 0x3f, 0xc1, 0x93, 0xcf, 0xd3, 0x75, 0xa8, 0xa7, 0xf7, 0x57,
	0x95, 0x41, 0xef, 0x4b, 0x68, 0x27, 0xcf, 0x70, 0x7a, 0xe3, 0x05, 0x49, 0xa1, 0xe5, 0x14, 0xdf,
	0x37, 0xe4, 0xde, 0x74, 0xbe, 0x8f, 0xec, 0xd8, 0xcb, 0x0f, 0x3f, 0x88, 0xb7, 0xee, 0xf7, 0xf2,
	0xd4, 0x15, 0xe4, 0x27, 0x3e, 0xad, 0xa7, 0x7f, 0xda, 0xc7, 0xa8, 0xaf, 0xdf, 0xf4, 0x0b, 0x03,
	0x0e, 0x86, 0x89, 0x17, 0xa5, 0xf7, 0x38, 0xd1, 0x8b, 0xfd, 0x67, 0x79, 0xb1, 0x7f, 0x90, 0xb0,
	0x7a, 0xce, 0x13, 0x35, 0xdd, 0x3f, 0x70, 0x58, 0x64, 0xf2, 0xc8, 0x32, 0x9e, 0x02, 0xa4, 0xa4,
	0x7b, 0x82, 0x45, 0xf4, 0x17, 0xce, 0xd9, 0x01, 0x0d, 0x12, 0xa0, 0xd9, 0xd4, 0x09, 0xaf, 0x0d,
	0x68, 0x6f, 0x1a, 0x16, 0xf4, 0x05, 0x54, 0x46, 0x3d, 0x31, 0xca, 0x44, 0xa2, 0xba, 0xdd, 0x13,
	0xe3, 0x4b, 0x24, 0xaa, 0x3b, 0x3d, 0x31, 0xb9, 0x44, 0x62, 0xf1, 0x96, 0x98, 0x5d, 0x22, 0xb1,
	0x78, 0xab, 0xbd, 0x2d, 0xe2, 0x99, 0xee, 0x58, 0xed, 0xba, 0x88, 0xb7, 0xf8, 0xe0, 0xef, 0x14,
	0x06, 0x7f, 0x57, 0x0c, 0x3e, 0xfa, 0x1a, 0xea, 0x09, 0x9e, 0x52, 0xfa, 0x0d, 0x4a, 0xdf, 0x15,
	0x9a, 0xf9, 0x13, 0x34, 0xd4, 0xfd, 0xd1, 0x94, 0x07, 0xb9, 0xa3, 0x1e, 0xa8, 0x96, 0xcb, 0x1d,
	0x95, 0x9b, 0x16, 0x1c, 0x96, 0x4d, 0xdf, 0xfa, 0x5e, 0x73, 0x65, 0x8e, 0x6b, 0xbe, 0x35, 0xc8,
	0x2a, 0x23, 0x85, 0x46, 0x3f, 0xc2, 0xde, 0x6d, 0x48, 0xaa, 0x69, 0x0f, 0x17, 0x97, 0x5e, 0x18,
	0x7a, 0x22, 0xa1, 0x68, 0x54, 0x51, 0x8e, 0x8c, 0xaa, 0x68, 0x51, 0xd2, 0x48, 0x57, 0x9f, 0x82,
	0xe1, 0xb5, 0x52, 0x3a, 0x5b, 0x8b, 0xd2, 0x57, 0x13, 0x6b, 0x51, 0xfa, 0x4c, 0xa8, 0x0c, 0x7b,
	0xac, 0x7a, 0x4d, 0x0b, 0x15, 0x9a, 0xcc, 0x4f, 0x82, 0x38, 0x73, 0x89, 0x97, 0xc5, 0xf0, 0x8a,
	0x6e, 0x8a, 0xb1, 0xcc, 0x21, 0xc0, 0xca, 0xc2, 0x17, 0xb9, 0x51, 0x58, 0xe4, 0xe2, 0xf3, 0x1d,
	0x84, 0xa0, 0x36, 0xf0, 0xd2, 0x99, 0x60, 0xc9, 0x64, 0x7a, 0x0f, 0x77, 0xf6, 0x3c, 0x9e, 0x49,
	0x7e, 0x42, 0x23, 0xfb, 0xf0, 0x9b, 0x0d, 0xc3, 0x88, 0xbe, 0x84, 0xea, 0xa8, 0x27, 0xfb, 0x86,
	0x8a, 0xdc, 0x62, 0x89, 0x83, 0xa8, 0xc8, 0x2c, 0x96, 0xec, 0x1d, 0x2a, 0x72, 0x8b, 0xec, 0x1e,
	0x2a, 0x72, 0xaa, 0xdb, 0x05, 0xaa, 0x75, 0xf9, 0xe6, 0xbc, 0x34, 0xe0, 0x68, 0xe3, 0xc0, 0xa1,
	0x36, 0xec, 0x5c, 0x27, 0xd3, 0x2b, 0x2f, 0xe4, 0xd3, 0xd1, 0x70, 0xa5, 0x2a, 0x5a, 0xba, 0xa2,
	0xb7, 0x34, 0x69, 0xd9, 0xaa, 0x6a, 0x59, 0x52, 0x02, 0x32, 0x06, 0xb6, 0xa0, 0xc1, 0x64, 0x61,
	0x73, 0x04, 0x15, 0x26, 0x93, 0x09, 0xab, 0xf9, 0xe4, 0x58, 0x51, 0xfa, 0xd5, 0xd3, 0x4a, 0xa7,
	0x94, 0x79, 0xac, 0x01, 0x54, 0xfa, 0x36, 0x79, 0x1f, 0xd4, 0xb3, 0x41, 0xdf, 0xc8, 0xe0, 0x3e,
	0xf0, 0x89, 0x88, 0xd4, 0x2e, 0x52, 0xbf, 0x20, 0x3a, 0x48, 0x37, 0xf1, 0x39, 0x37, 0xb7, 0xce,
	0x8c, 0x5f, 0x0d, 0xeb, 0x9d, 0x01, 0x55, 0xc2, 0x1f, 0xfd, 0x0d, 0x4d, 0x6d, 0x54, 0x51, 0xa7,
	0xe4, 0xb1, 0x93, 0x60, 0xc7, 0xa5, 0x3e, 0x1d, 0x95, 0xac, 0x33, 0x58, 0x5d, 0x20, 0x3a, 0x5a,
	0xdf, 0xb0, 0x12, 0xab, 0x53, 0xe6, 0x2a, 0x40, 0x5d, 0x43, 0x4b, 0xbf, 0x0b, 0x74, 0x5c, 0xb6,
	0x12, 0x25, 0xdc, 0x49, 0xb9, 0x53, 0x07, 0x74, 0x7e, 0xb9, 0xfb, 0x79, 0x1a, 0x64, 0xb3, 0xe5,
	0xb8, 0x4b, 0x06, 0xf7, 0x1c, 0x87, 0x61, 0xfe, 0xff, 0xbf, 0x31, 0xfb, 0x7f, 0xbe, 0xfe, 0xdb,
	0x6c, 0x5c, 0x67, 0xbf, 0xcb, 0x7e, 0x7b, 0x1f, 0x00, 0x00, 0xff, 0xff, 0x33, 0x67, 0x8c, 0x49,
	0xb8, 0x09, 0x00, 0x00,
}
